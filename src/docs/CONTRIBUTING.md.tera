

Thank you for considering investing your time in contributing to Launchpad Namespaces! As an open source project it depends on a strong community to florish, and we welcome any type of contribution (not just code) that aligns with our [Code of Conduct].
Some of the ways to contribute:

- Community:
- Opening issues: by being a user and taking the time to report issues you've ran into. Please see the opening issues section below, on how to do that.
- Code:

# Opening an Issue

# Contributing Code

## Requirements

To contribute code, there's a few requirements you need to go through first:

### yarn

Our Git hooks system and some of our dependencies for tasks such as code generating or templating are being managed by yarn, so that will be required

### tera-cli

Some of our documentation is templated with this tool, and for those tasks to run sucessfully tera-cli must be available

### CUE

Namespaces schemas are written in cue-lang and you will need this

After having taken care of satisfying the previous requirements in an appropriate way in your OS, your next step should be to clone this repository and initialize yarn packages with

> yarn install

From a setup point of view you should be ready to go. Keep reading for a brief overview of the repository layout and implementation details.

## Repository Layout

### `./src`

This repository has a lot of dynamically generated content and artifacts, and the source of truth for all of those resides in /src

### `./src/schemas`

In here you'll find all the schemas which are the source of truth for every namespace helmfile. Amon them also resides `generate_tool.cue`, which implements the logic for actually generating all the outputs from the schemas.

### `./src/scripts`

Here reside convenience scripts to regen helmfiles, docs, openAPI JSON schema files, ...

### `./src/docs`

Base templates for several document files, and some macros used in the templating

### `./<namespace>`

Each namespace has its own folder where their artifacts reside

### `./<namespace>/values`

The default values for the namespace. In case the namespace has more than one flavor (different sets of defaults), then those reside in `/<namespace>/values/<flavor>`, and the `_common` folder contains the common values shared by all flavors.

## Implementation Details

A Namespace is comprised of two things:
- A set (or more, when the namespace has different flavors) of default values for the releases (helm charts)
- An helmfile.yaml with some templating logic evaluated client-side "at runtime", by helmfile. This templating logic implements the interface and features available (... like dictionary merging the user-passed values on top of the default ones, or toggling some releases on/off depending on features)

The default values are static data, and can be found in the `{namespace}/values` folders.

The helmfile.yaml file is dynamically built from schema files written in CUE (check the repository layout for a more compreensive description of the structure).

Those schema files completely define the namespace in its many characteristics, such as:
- what releases they bundle, and the helm chart repos in which to find those releases
- what features it supports
- the labels its releases get deployed with

### values merging

This is often implemented in the helmfiles in code such as
{% raw -%}
<code>
{{ $__helmDefaults := `{"recreatePods":true}` | fromJson }}
{{ with ( .Values | get "helmDefaults" dict ) }}
{{ $_ := (deepCopy . | mergeOverwrite $__helmDefaults) }}
{{ end }}
</code>
{%- endraw -%}
which consists of declaring a variable holding a default value, and deep merging with the user passed values, giving precedence to those. Injecting the default value, recreatePods in this example, is done by the CUE tool when building the helmfiles.

### flavors

Flavors are implemented by having different sets of values in different subfolders, and having the helmfile lookup the folder dynamically, as shown in this example
{% raw -%}
<code>
{{- if ( hasKey .Values "flavor" ) }}
- ./values/_common/{{` "`{{ .Release.Name }}`" `}}.yaml
- ./values/{{ .Values.flavor }}/{{` "`{{ .Release.Name }}`" `}}.yaml
{{- else }}
- ./values/{{` "`{{ .Release.Name }}`" `}}.yaml
{{- end -}}
</code>
{%- endraw -%}

### features

Features are implemented by wrapping the releases in the helmfile with a conditional, as seen in the following example:
{% raw -%}
<code>
{{ if has "metrics" ( .Values | get "features" list ) }}
{{- $release := "kube-prometheus-stack" }}
- name: 'kube-prometheus-stack'
  inherit:
  - template: 'kube-prometheus-stack'
  values:
  {{- tpl $_tplReleaseValues (dict "Values" .Values "release" $release)  | indent 4 -}}
{{- end -}}
</code>
{%- endraw -%}
